# 第二章

- 声明和定义的区别使得分离式编译得以实现
    - 声明使得名字为程序所知晓
    - 定义负责创建与名字关联的实体
- `extern` 声明变量
    - 由此关键字修饰的变量（不含初始化）是声明而非定义
    - 包含初始化时，`extern` 的作用就会被抵消，而变为单纯的定义
    - 变量只能被定义一次，但可以多次被声明
- 引用不是对象，它只是一个已存在对象的另一个名字
    - 引用必须被初始化而因此被绑定到初始化指定的对象，且无法再被绑定到另一个对象
    - （初始化之后）对引用的操作实际上是对其绑定的对象的操作
    - 引用只能绑定到某个对象上，不能绑定到字面值或表达式的值（**有例外**）
- 基本数据类型和类型修饰符的关系：后者是声明符的一部分
    - 变量定义由基本数据类型和一系列声明符构成
- `const` 限定符
    - 由此限定符修饰的对象不可以被赋值，因此它必须被初始化
    - 默认情况下，`const` 对象仅在当前文件内有效，多个文件中的同名 `const` 变量相当于是分别定义的独立变量
    - 对于确有需要对 `const` 变量像普通变量那样共享的情况，解决办法是不论声明还是定义 `const` 变量，都用 `extern` 进行修饰
    - 对 `const` 的引用，简称“常量引用”，不能被用来修改其绑定的对象
    - 前面对引用绑定对象的限制的例外情况是：**允许为“常量引用”绑定非常量的对象、字面值，甚至表达式**
    - “常量引用”仅对引用能参与的操作做了限制，而对引用的对象本身是否为常量不作限制，就是说，“常量指针”不能用来改变引用对象的值，不论引用的是常量还是非常量对象
- `constexpr` 用于明确声明在编译器可以求值的表达式
    - 一般来说函数内的局部变量不能用于初始化 `constexpr` 的对象
    - `constexpr` 用于修饰指针时，只能用来限制指针对象，而与指针指向的对象无关
- 类型别名，在使用类型别名声明变量时，不能单纯地“展开”别名
- `auto` 能让编译器帮助程序员推断数据类型，必须进行初始化
    - `auto` 推断时会忽略**顶层 `const`**，同时**底层 `const`**会保留
- `decltype` 类型指示符，编译器分析传递给它的表达式并得到它的类型，却不实际计算表达式
    - 若表达式是变量，那么返回该变量的类型（包括**顶层 `cosnt`**）
    - 若表达式是加括号的变量，那么必定返回引用类型
    - 需要指出的：引用用作 `decltype` 时，其含义不再是所指对象的别名（因为那将不会返回引用类型，仅此一例例外）
    - 若表达式是解引用操作时，返回引用类型
- 赋值是会产生引用的典型表达式，引用的类型就是左值的类型
- 属于类的每个对象有自己的一份数据成员拷贝